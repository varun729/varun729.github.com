= Reading Notes

== The case for the reduced instruction set computer
=== David A. Patterson; David R. Ditzel

This paper gives arguments in favor of RISC instruction set. The main argument
is the complexity and speed of execution. Given that CISC instruction set is
more complex, it takes more time to implement the architecture. The microcode
(architecture logic) also is more complicated and needs more die space. Only a
fraction of the instruction set is actually used while running any program, thus
complex instructions can be broken into several simple instructions. There are
certain complex instructions which take more time than simpler implementations.

Overall the point of the paper was towards the complexity and the increased cost
on all fronts - design, manufacture, debug, die space. With RISC architecture,
because of simpler logic, more space on the die could be used for cache memory,
or pipelining.

The examples in the paper and handpicked and prove the point nicely. But there
is no concrete definition of a RISC or even a CISC architecture. How to
differentiate between a complex design from a simpler one, where to draw the
line?

== Comments on "the case for the reduced instruction set computer"
=== Douglas W. Clark; William D. Strecker

This is a comment by people at VAX Systems Architecture. This is a contradictory
report which counters almost all the points in the paper /The case for the
reduced instruction set computer/. Without a concrete RISC implementation, with
a supporting compiler, and OS, it would be difficult to compare the two
different architectures. The authors acknowledge the the different architecture,
but, the examples used in the original paper were too specific. They show that
programs in two different programming languages use very different instructions,
and using a simpler instruction set may not be feasible for all languages.

A major point which is raised is, by removing complexity from the hardware, the
software becomes more complex now. And thus the compiler-writers need to take
care of all the complexity in software. How to compare the complexity in
hardware space with the complexity in software space?
