= Reading Notes

== The case for the reduced instruction set computer
=== David A. Patterson; David R. Ditzel

This paper gives arguments in favor of RISC instruction set. The main argument
is the complexity and speed of execution. Given that CISC instruction set is
more complex, it takes more time to implement the architecture. The microcode
(architecture logic) also is more complicated and needs more die space. Only a
fraction of the instruction set is actually used while running any program, thus
complex instructions can be broken into several simple instructions. There are
certain complex instructions which take more time than simpler implementations.

Overall the point of the paper was towards the complexity and the increased cost
on all fronts - design, manufacture, debug, die space. With RISC architecture,
because of simpler logic, more space on the die could be used for cache memory,
or pipelining.

The examples in the paper and handpicked and prove the point nicely. But there
is no concrete definition of a RISC or even a CISC architecture. How to
differentiate between a complex design from a simpler one, where to draw the
line?

== Comments on "the case for the reduced instruction set computer"
=== Douglas W. Clark; William D. Strecker

This is a comment by people at VAX Systems Architecture. This is a contradictory
report which counters almost all the points in the paper /The case for the
reduced instruction set computer/. Without a concrete RISC implementation, with
a supporting compiler, and OS, it would be difficult to compare the two
different architectures. The authors acknowledge the the different architecture,
but, the examples used in the original paper were too specific. They show that
programs in two different programming languages use very different instructions,
and using a simpler instruction set may not be feasible for all languages.

A major point which is raised is, by removing complexity from the hardware, the
software becomes more complex now. And thus the compiler-writers need to take
care of all the complexity in software. How to compare the complexity in
hardware space with the complexity in software space?

== RISC : A reduced instruction set VLSI computer
=== David A. Patterson; Carlo H. Sequin

This paper talks about the details of the first implementation of the RISC
machine. It is tested on a student simulator, and thus performance results are
only estimates. The most astonishing feature of the paper is that the number of
instructions is only 2/3rd more than a CISC machine (e.g. VAX). Since the
instructions are simple, the program size was expected to bloat up, especially
when no effort was made to reduce the program size.

Another astonishing feature was that in CISC machines there were more than 50%
memory operations, but with RISC architecture the memory operations were reduced
to around 20%. This is due to the overlapping register windows, which allows
passing values to routines through registers instead of passing on stack. Since
most of the memory accesses were due to call/return procedures, by using
overlapping register windows, RISC was able to reduce the memory accesses. Most
variable accesses were found to be local variables, and thus by keeping them in
registers, memory accesses are reduced. This was only possible because of the
huge register set (32 registers, and set of overlapping register banks).

The register inputs for every instruction are prefetched in the previous
instruction. Since this was a problem with the branch instructions, all the
branch instructions are delayed by one instruction. Thus, every branch is
followed by a NOP. By rearranging instructions, we can have useful instructions
executed after the branch - this reduces the NOP count.

== The CRAY-1 computer system
=== Richard M. Russell

This paper is mostly about the technical details of designing the architecture
and how a product was built. The vector processing is the most powerful peice in
the design of this massive system. The other important feature is the
'chaining', which is similar to the data forwarding, but user can control this
chaining, whereas data forwarding is not in user control.

The CRAY-1 computer system uses almost all the technological advances at the
time and builds it together into a powerful system. The novelness is being able
to build the powerful system, with the latest technology. The machine uses
integrated circuits, which reduces the size.
