<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta name="generator" content="jemdoc, see http://jemdoc.jaboc.net/" />
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<link rel="stylesheet" href="jemdoc.css" type="text/css" />
<title>Reading Notes</title>
</head>
<body>
<div id="layout-content">
<div id="toptitle">
<h1>Reading Notes</h1>
</div>
<h2>The case for the reduced instruction set computer</h2>
<h3>David A. Patterson; David R. Ditzel</h3>
<p>This paper gives arguments in favor of RISC instruction set. The main argument
is the complexity and speed of execution. Given that CISC instruction set is
more complex, it takes more time to implement the architecture. The microcode
(architecture logic) also is more complicated and needs more die space. Only a
fraction of the instruction set is actually used while running any program, thus
complex instructions can be broken into several simple instructions. There are
certain complex instructions which take more time than simpler implementations.</p>
<p>Overall the point of the paper was towards the complexity and the increased cost
on all fronts - design, manufacture, debug, die space. With RISC architecture,
because of simpler logic, more space on the die could be used for cache memory,
or pipelining.</p>
<p>The examples in the paper and handpicked and prove the point nicely. But there
is no concrete definition of a RISC or even a CISC architecture. How to
differentiate between a complex design from a simpler one, where to draw the
line?</p>
<h2>Comments on &ldquo;the case for the reduced instruction set computer&rdquo;</h2>
<h3>Douglas W. Clark; William D. Strecker</h3>
<p>This is a comment by people at VAX Systems Architecture. This is a contradictory
report which counters almost all the points in the paper <i>The case for the
reduced instruction set computer</i>. Without a concrete RISC implementation, with
a supporting compiler, and OS, it would be difficult to compare the two
different architectures. The authors acknowledge the the different architecture,
but, the examples used in the original paper were too specific. They show that
programs in two different programming languages use very different instructions,
and using a simpler instruction set may not be feasible for all languages.</p>
<p>A major point which is raised is, by removing complexity from the hardware, the
software becomes more complex now. And thus the compiler-writers need to take
care of all the complexity in software. How to compare the complexity in
hardware space with the complexity in software space?</p>
<h2>RISC : A reduced instruction set VLSI computer</h2>
<h3>David A. Patterson; Carlo H. Sequin</h3>
<p>This paper talks about the details of the first implementation of the RISC
machine. It is tested on a student simulator, and thus performance results are
only estimates. The most astonishing feature of the paper is that the number of
instructions is only 2/3rd more than a CISC machine (e.g. VAX). Since the
instructions are simple, the program size was expected to bloat up, especially
when no effort was made to reduce the program size.</p>
<p>Another astonishing feature was that in CISC machines there were more than 50<tt>
memory operations, but with RISC architecture the memory operations were reduced
to around 20</tt>. This is due to the overlapping register windows, which allows
passing values to routines through registers instead of passing on stack. Since
most of the memory accesses were due to call/return procedures, by using
overlapping register windows, RISC was able to reduce the memory accesses. Most
variable accesses were found to be local variables, and thus by keeping them in
registers, memory accesses are reduced. This was only possible because of the
huge register set (32 registers, and set of overlapping register banks).</p>
<p>The register inputs for every instruction are prefetched in the previous
instruction. Since this was a problem with the branch instructions, all the
branch instructions are delayed by one instruction. Thus, every branch is
followed by a NOP. By rearranging instructions, we can have useful instructions
executed after the branch - this reduces the NOP count.</p>
<div id="footer">
<div id="footer-text">
Page generated 2013-12-03 01:35:33 EST, by <a href="http://jemdoc.jaboc.net/">jemdoc</a>.
</div>
</div>
</div>
</body>
</html>
