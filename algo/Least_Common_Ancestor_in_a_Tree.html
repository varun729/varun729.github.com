<html itemscope itemtype="http://schema.org/">
<head>
<link rel="stylesheet" href="../css/page.css" type="text/css" />
<title>Least Common Ancestor in a Tree</title>
<!-- Place this tag where you want the +1 button to render -->

<!-- Add the following three tags inside head -->
<meta itemprop="name" content="Least Common Ancestor in a Tree">
<!--<meta itemprop="description" content="This would be a description of the content
your users are sharing">-->

<!-- Place this render call where appropriate
<script type="text/javascript">
(function() {
var po = document.createElement('script'); po.type = 'text/javascript';
po.async = true;
po.src = 'https://apis.google.com/js/plusone.js';
var s = document.getElementsByTagName('script')[0];
s.parentNode.insertBefore(po, s);
})();
</script>
-->
</head>
<body>

<div class="page">

<div class="header">
[<a href="../index.html" >home</a>]
[<a href="../algo/index.html" >algorithms</a>]
[<a href="../blog/index.html" >blog</a>]
</div>

<hr />

<div class="content">
<i>Wednesday, Feb 29, 2012 </i>
<h2>Least Common Ancestor in a Tree</h2>
<p>
[Under progress]
</p>
<h3>Introduction</h3>
<p>
Trees are one of the basic data structures used regularly. It is very
straight-forward to design a tree, and use it. But the complexity arises when
analysis has to be done on the tree. Trees are helpful in modeling parent child
relationships between objects and when the distance between objects is not very
important. But since the only information with every object is about its parent
and its child, doing any analysis other than that requires traversal as one of
the steps, which itself takes O(n) time. When the analysis is to be done once,
it is not okay, but if it is to be done multiple times, it becomes costly.
</p>
<p>
One of the problems which is difficult to solve directly is finding the smallest
sub-tree containing given leaf nodes. One solution is <b>the whole tree</b>. But
it is possible to find smaller sub-trees which also contain the given leaves.
One way is to look at each intermediate node, and find all the leaf nodes in it
and then see if it contains given leaves. This can take O(n^2) time. For large
trees this is not feasible, and imagine doing this in a UI application!
</p>
<img src="img/tree/tree.png" />
<p>
This problem is called the <b>Least Common Ancestor</b> problem. And this
write-up discusses different algorithms to find it, with decreasing order of
complexity.
</p>
<p>
(This is based upon a talk by <b>Dr. Ramesh Hariharan</b> at <b>Strand Life
Sciences</b>.)
</p>


<h3>Linear Tree</h3>
<p>
As can be seen in the figure below, a linear tree can give solution in O(1)
time. The node which is upper in the tree, is the least ancestor.
</p>
<img src="img/tree/linear.gif" />
<p>
Lets look at more complex trees.
</p>

<hr />


<h3>Trees as arrays</h3>
<p>
As we just saw that, with a linear tree the problem becomes very simplified.
Searching for a node in a linear data structure is much more simpler than in a
linked list. Trees are usually stored as a linked list, and although finding the
least common ancestor using this data structure is possible it takes more than
linear time.
</p>
<p>
<img src="img/tree/simple.png" />
<img src="img/tree/simple.gif" />
</p>
<p>
In order to simplify the search of the LCA, we can do some pre-processing which
will then make the runtime much faster. The data structure which we will use is
as described below:
</p>
<p>
We traverse the tree as is shown in the array below. The data structure
remembers the rank of the node during traversal. Rank is the distance from the
topmost node.<br />
Traversal -> [1 2 3 4 3 5 3 2 1 6 7 6 8 6 1]<br />
Data structure -> [0 1 2 3 2 3 2 1 0 1 2 1 2 1 0]<br />
<img src="img/tree/simple-traverse.gif" />
</p>

<h3>Finding LCA in linear time</h3>
<p>
Creating a data structure which takes 2*n space, O(n), by pre-computing, and
then using it to find the LCA in O(n) time
</p>

<h3>Finding LCA in constant time</h3>
<p>
Creating a data structure which takes O(n*log(n)) space, but finds the LCA
in O(1) time
</p>

<h3>Finding LCA in constant time with linear time pre-computation</h3>
<p>
Creating a data structure which takes O(n) space with the help of blocks and
then finds the LCA in O(1) time.
</p>

</p>


<!-- g+ button
<g:plusone></g:plusone>
-->
<!-- Tweet button
<a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
-->
<!--
<script>!function(d,s,id){var
js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
-->

</div>

</div>

</body>
</html>
